# 24장 리팩터링

### 리팩터링하는 이유
- 코드가 중복되어 있다.
- 루틴이 너무 길다.
- 루프가 너무 길거나 깊이 중첩되어 있다.
- 클래스의 응집력이 약하다.
- 클래스 인터페이스가 일관된 추상화 수준을 제공하지 않는다.
- 매개변수가 너무 많다.
- 클래스 내의 변경 사항이 상호 관계를 고려하지 않고 구분되는 경향이 있다.
- 변경할 때 여러 개의 클래스를 동시에 수정해야 한다.
- 상속계층 구조가 병렬로 변경되어야 한다.
- case 문이 병렬로변경돼야 한다.
- 함께 사용되는 연관된 데이터 항목이 클래스로 구성되지 않앗다.
- 루틴이 자신이 포함된 클래스보다 다른 클래스의 기능을 더 많이 사용한다.
- 클래스가 많은 일을 수행하지 않난다.
- 일련의 루틴이 뜨내기 데이터를 전달한다. 
뜨내기데이터: A함수에서 B함수로 파라미터 바이패싱하는 역할만 할 때
- 중개 역할을 하는 객체가 아무것도 하지 않는다.
- 한 클래스가 지나치게 다른 클래스를 ㅊ마견한다.
- 루틴의 이름이 엉성하다.
- 공개 데이터 멤버다.
- 서브클래스는 부모 클래스 루틴의 일부만을 사용한다.
- 주석을 이용해 어려운 코드를 설명한다.
나쁜코드는 문서화 하지 말고 다시 작성하라.
- 전역 변수를 사용한다.
- 루틴이 루틴을 호출하기 전에 설정 코드를 사용하거나 루틴을 호출한 다음에 분해코드를 사용한다.
- 프로그램이 언젠가 필요할 것 같은 코드를 포함하고 있다.

## 구체적인 리팩터링
### 데이터 수준 리팩터링
- 매직 넘버를 이름 상수로 대체한다.
- 변수 이름을 더 분명하고 많은 정보를 제공하는 이름으로 다시 짓는다.
- 표현식을 인라인화한다.
- 중간 변수를 사용한다.
- 여러 목적으로 사용되는 변수를 단일 목적을 갖는 변수 여러개로 변환한다.
- 로컬에서 사용할 목적이라면 매개변수 대신 지역 변수를 사용한다.
- 기본형 데이터를 클래스로 변환한다.
- 형 선언 코드 집합을 클래스나 열거형으로 변환한다.
- 배열을 객체로 변경한다.
- 컬렉션을 캡슐화한다.
- 전형적인 레코드를 데이터 클래스로 대체한다.

### 명령문 수준 리팩터링
- 불린 표현식을 분해한다.
- 복잡한 불린 표현식을 명확한 이름의 불린 함수로 옮긴다.
- 서로 다른 조건문 내에 중복으로 사용된 코드를 결합한다.
- 루프 제어 변수 대신 break나 return을 사용한다.
- 중첩된 if - then - else 명령문 내에서 리턴값을 할당하는 대신 곧바로 리턴한다.
- 조건문을 다형성으로 대체한다.
- null 값을 테스트하는 대신 null 객체를 생성하여 사용한다.

### 루틴 수준 리팩터링
- 루틴을 추출한다/메서드를 추출한다.
- 루틴의 코드를 인라인화한다.
- 긴 루틴을 클래스로 변환한다.
- 복잡한 알고리즘 대신 간단한 알고리즘을 사용한다.
- 매개변수를 추가한다.
- 배개변수를 제거한다.
- 변경 연산과 쿼리 연산을 구분한다.
- 매개변수를 이용하여 유사한 루틴을 결합한다.
- 전달되는 매개변수에 따라 행동하는 루틴을 분리한다.
- 특정한 필드 대신 전체 객체를 전달한다.
- 전체 객체 대신 특정한 필드만 전달한다.
- 다운캐스팅을 캡슐화한다.
객체를 리턴할 때, 가장 구체적인 형태(타입)의 객체를 리턴한다.

### 클래스 구현 리팩터링
- 값 객체를 참조 객체로 변경한다.
- 참조 객체를 값 객체로 변경한다.
- 가상 루틴을 데이터 초기화로 대체한다.
리턴값만 다른 서브클래스가 있다면, 오버라이드 하지말고 적절한 상수 값으로 클래스 초기화한 후 그 값을 사용하는 일반적인 코드를 기본 클래스에 넣는다.
- 멤버 루틴이나 데이터의 위치를 변경한다.
- 특화된 코드를 서브클래스로 추출한다.
- 유사한 코드를 슈퍼클래스로 결합한다.

### 클래스 인터페이스 리팩터링
- 루틴을 다른 클래스로 이동
- 한 클래스를 두 개로 변환
- 클래스를 제거
- 위임을 숨긴다.
A가 B를, B가 C를 호출하고 있다. A가 B와 C를 모두 호출하도록 변경해야 할 때, A는 B를 통해서 C를 호출하도록 한다.
- 중개자를 제거한다.
위 케이스에 B를 제거하는게 좋을 수도 있다. 위임여부는 B의 인터페이스 무결성을 최적으로 유지할 것인지에 달려있다.
- 상속을 위임으로 대체한다.
- 위임을 상속으로 대체한다.
- 외부 루틴을 도입한다.
- 확장 클래스를 도입한다.
- 노출된 멤버 변수를 캡슐화한다.
- 변경할 수 없는 필드에 대한 Set() 루틴을 제거한다.
- 클래스 외부에서 사용하면 안되는 루틴을 숨긴다.
- 사용되지 않는 루틴을 캡슐화한다.
- 슈퍼클래스와 서브클래스의 구현이 매우 유사하다면 이 둘을 결합한다.

### 시스템 수준 리팩터링
- 제어할 수 없는 데이터에 대해 명확한 참조 소스를 생성한다.
input 값 같은 경우 데이터와 별개로 다루다가 마지막에 데이터에 반영
- 단방향 클래스 관계를 양방향 클래스 관계로 바꾼다.
- 양방향 클래스 관계를 단방향 클래스 관계로 바꾼다.
- 간단한 생성자 대신 팩토리 메서드를 제공한다.
- 오류 코드를 예외로 대체하거나 그 반대로 한다.

## 안전한 리팩터링 방법
- 리팩터링 시작 전에 코드를 저장한다.
- 리팩터링을 작게 유지한다.
- 리팩터링은 한 번에 하나만 수행한다.
- 수행할 단계에 대한 목록을 만든다.
- 주차장을 만든다.
주차장: 지금 당장 변경할 필요는 없지만 어느 시점에 변경해야하는 사항에 대한 목록
- 체크 포인트를 자주 설정한다.
- 컴파일러 경고를 활용한다.
- 다시 테스트한다.
- 테스트 케이스를 추가한다.
- 변경 사항을 검토한다.
- 리팩터링 위험 수준에 따라서 접근방법을 조절한다.

### 리팩터링에 좋지 않은 시기
- 코드를 작성하고 수정하는 것을 감추는 용도로 리팩토링을 사용하지 않는다.
- 코드를 재작성하는 대신 리팩터링 하지 않는다.
